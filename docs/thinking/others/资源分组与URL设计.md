---
date: !!timestamp 2019-05-31T00:00:00.00+08:00
---

# 资源分组与 URL 设计

在开始之前，我们先观察一下我们已经非常熟悉的 Linux 的文件系统的路径是如何设计的。比如

/etc/rc.d/rc.local

Linux 中从根目录开始，一层一层的检索想要获取的文件。根目录的名字是 “/”，他是固定不变的，在根目录后面是根目录中的文件名称，这里的名称是 rc.d/，然后以此类推，直到最终要访问的文件。

现在我需要问你一个问题，文件的名字是保存在哪里的？很多人一直以为文件的名字是保存在文件中的，但是实际上，文件仅仅保存了文件的内容，跟文件相关的其他属性都没有保存在文件中。其实文件的名字是保存在它所在的目录中的，也就是说目录其实也是文件，只是比较特殊，目录的内容就是目录中包含的文件的信息。

实际上我们计算机到硬盘中去取文件的时候根本不需要知道文件的名字或者路径，而是使用文件在硬盘上保存的位置，这个位置信息也保存在目录中。也就是说，我们在取文件的时候，首先到固定的位置获取根目录的内容，根目录中保存着根目录下的文件的名字和保存位置的映射关系，Linux 通过文件名字确定第二级目录的保存位置，然后再取第二级目录的位置，直到成功获取最终文件。

通常，一个文件只会保存在一个目录下，但是，实际上，一个文件是可以同时保存在多个目录下的，这样我们可以通过多个路径对同一个文件进行操作。

因为按照路径索引需要通过文件在目录中的名字获取它的保存位置，所以同一个目录下不能有两个同名的文件，这样我们才能在一个目录下唯一的确认一个文件。

但是按照目录索引还有一个很大的缺点，那就是因为不能直接获取文件的保存位置，想要检索某个文件就变得比较困难，如果你不知道你要查找的文件的完整路径，那么计算机只能通过依次在每个目录中检查你要检索的文件是否存在来帮助你了。而搜索文件的这个过程是十分漫长的。

但是，如果你记住了每个文件的保存位置，你可以直接通过这个保存位置来获取文件，这样可以跳过所有的目录层级，直接读取文件，这比使用路径访问文件还要快，但是这样会有更大的麻烦，没有人会记住他要是用的所有文件的保存位置。

但是，我们可以两种方式都使用，我们可以先使用层级目录的方式获得文件的保存位置，如果我们需要频繁的访问这个文件，我们可以把文件的位置记录下来，下次需要访问的时候直接使用这个保存位置操作文件。

理解了上面的内容对设计 URL 有哪些帮助呢？

文件的路径是文件名称的层级连接
文件的保存位置在硬盘上是唯一的
借助上面两条概念，我们在设计 URL 的时候也可以采取同样的措施，资源的名称不再是保存在文件的记录中，而是保存在父级资源组中，这样一个 URL 就变成了

/根资源组名称/次级资源组名称/…./资源名称

不过这样会有另外一个问题，文件系统中只有两种文件，目录和普通文件，而 URL 中，每一层资源组实际上都是一种资源，而不单单是为了组成索引。所以我们会需要看到 URL 就能知道每一层资源组具体对应着什么，比如

/某某公司/某某部门/某某办公室/某某人

我们需要在名字上直接说明资源组的类型，这样显然是浪费口舌，还有一种办法，就是把资源组先创建普通的组再添加到上级资源组中。比如

/公司/某某/部门/某某/办公室/某某/人/某某

这样，我们认为所有的公司在同一资源组中，而所有的公司在的组在根目录下。这样我们就可以轻松的了解资源组的性质，而且不需要为所有的资源组的名字加上资源组的类型。

不过还有一个问题，就是同一级目录中不能有两个重名的资源，如果我们在根目录下放了一个资源，他的名字就叫公司，这样和公司这个资源组会冲突。所以我们在起名字的时候就会更容易重名。不过我相信不会有人傻到犯这样的错误。

先将某种类型的资源放在这种类型的资源组成的组里再将这个组添加到父级资源组中，这样目录的层级就更加深了，就需要更多次的跳转了。如果目录的层级是固定的，比如部门一定是在公司下面的，那么我们可以通过他们的关系简化这个这种跳转。在层级是固定的情况下，如果你不在乎浏览者看到 URL 时会困惑的话，你也可以直接使用之前的方法，省略资源名称上的类型说明，直接使用

/某某/某某/某某/某某

这种索引方式。

但是最好的办法还是直接使用资源的保存位置来获取资源，在设计 URL 时，这个保存位置就是资源的 ID，不过不同的资源往往是保存在不同的表中的，我们需要先说明资源所在的表，通常表名和资源类型是有对应关系的，也就是说

/人/ID

可以直接说明我们要找的是谁。如果你不是特别在意资源的层级关系，这样检索还好，但是如果你同时希望原来的层级检索方式还可以用，这样的表达方式就会有歧义。

我们是要找一个资源类型为人，保存位置为 ID 的资源，还是在根目录下找一个类型为人，名字为 ID 的资源组？

我们可以通过在根目录下创建两个不同名字的目录来区别

/Indirect/公司/某某/部门/某某/办公室/某某/人/某某

和

/Direct/人/ID

很显然上面两种路径表示的意思是不一样的。

如果你觉得 Indirect 和 Direct 会让你的访问者困惑，你也可以通过 URL 参数来指定索引

/公司/某某/部门/某某/办公室/某某/人/某某

和

/人?id=ID

后者的目录在根目录下只有一层，很明显不是按照层级查找的。

当然你也可以混合着两种模式

/公司/不确定/部门/某某/办公室/某某/人/某某?公司 id=ID

或者

/公司/某某/部门/某某/办公室/某某/人?人 id=ID

甚至

/人/某某?办公室 id=办公室 ID

当然，这样的索引即难写又难读，不推荐混合使用。

既然我们可以使用 id 来所有，那么使用名字搜索其实也不是不可以

/公司/某某/部门/某某/办公室/某某/人?name=Name

这样的表示方式和

/公司/某某/部门/某某/办公室/某某/人/某某

检索的结果一样，反而描述更加复杂了，似乎没有什么必要，但是我们可以这样检索

/公司/某某/人?name=Name

很明显，这样得到的应该是某某公司里所有名字为 Name 的人。原来的表达方式是没法完成这样的操作的。除了要实现这样的接口，你还必须把某某公司所有的人组成一个资源组并添加到某某公司下面，当然你的接口自动按照层级依次检索也没有什么问题，只是那样要执行的操作就太多了。
